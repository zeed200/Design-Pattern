نمط Chain of Responsibility (سلسلة المسؤولية) هو واحد من أنماط التصميم السلوكية (Behavioral Design Patterns) التي تسمح لك بتمرير الطلبات (Requests) عبر سلسلة من المعالجين (Handlers).
عندما يصل طلب ما، يقوم كل معالج في السلسلة بتقرير إما معالجة الطلب أو تمريره إلى المعالج التالي في السلسلة.


تخيل أنك تتصل بخدمة العملاء في شركة اتصالات:

الرد الآلي يستقبلك (المعالج الأول): إذا كانت مشكلتك بسيطة (شحن رصيد)، يحلها وتنتهي السلسلة.
إذا لم يحلها، يحولك لموظف الدعم الفني (المعالج الثاني): إذا كانت مشكلة تقنية عادية، يحلها.
إذا كانت المشكلة معقدة جداً، يحولك للمدير التقني (المعالج الثالث).

الهدف: فك الارتباط بين مرسل الطلب ومستقبله. المرسل لا يعرف من الذي سيحل المشكلة بالضبط، هو فقط يضعها في "السلسلة".

المكونات الرئيسية :

Handler (واجهة المعالج): تحدد الواجهة البرمجية التي يجب أن يتبعها كل معالج (غالباً دالة handle).
Concrete Handlers (المعالجون الفعليون): يحتوي كل منها على الكود الخاص بمعالجة نوع معين من الطلبات.
Client (العميل): هو من يقوم بتكوين السلسلة وإرسال الطلب لأول عنصر فيها.

في Django، نحن نستخدم هذا النمط يومياً دون أن نشعر، وهو يتجسد في الـ Middleware.

عندما يأتي طلب (Request) إلى Django:

يمر عبر SecurityMiddleware.
ثم يمر عبر SessionMiddleware.
ثم AuthenticationMiddleware.
وهكذا حتى يصل إلى الـ View.

كل Middleware يقرر: هل يقوم بعمل شيء (مثل التأكد من هوية المستخدم) ثم يمرر الطلب للذي يليه باستخدام get_response(request)، أم يقطع السلسلة ويرجع خطأ فوراً (مثلاً Redirect لصفحة تسجيل الدخول)؟

متى نستخدم هذا النمط؟

عندما يحتاج الطلب المرور بعدة مراحل تصفية أو فحص (Filters/Checks).
عندما تريد تنفيذ مجموعة من المعالجات بترتيب معين.
عندما لا تريد تحديد المستلم النهائي للطلب بشكل مسبق.

المميزات:

مرونة عالية: يمكنك إضافة أو حذف أو تغيير ترتيب السلسلة بسهولة.
مبدأ المسؤولية الواحدة (SRP): كل كلاس مسؤول عن فحص واحد فقط.

العيوب:

قد ينتهي الطلب دون أن يعالجه أحد إذا لم تضع معالجاً نهائياً افتراضياً.
يصعب تتبع المسار أحياناً إذا كانت السلسلة طويلة جداً.